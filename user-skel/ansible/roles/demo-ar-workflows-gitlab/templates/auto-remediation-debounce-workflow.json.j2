{
  "title": "{{ workflow_name }}",
  "taskDefaults": {},
  "usages": [],
  "description": "",
  "labels": {},
  "isPrivate": false,
  "triggerType": "Event",
  "schemaVersion": 3,
  "trigger": {
    "eventTrigger": {
      "isActive": true,
      "filterQuery": "event.kind == \"DAVIS_PROBLEM\" AND event.category == \"ERROR\" AND isNotNull(root_cause_entity_id)",
      "uniqueExpression": null,
      "triggerConfiguration": {
        "type": "event",
        "value": {
          "query": "event.kind == \"DAVIS_PROBLEM\" AND event.category == \"ERROR\" AND isNotNull(root_cause_entity_id)",
          "eventType": "events"
        }
      }
    }
  },
  "tasks": {
    "debounce_event_trigger": {
      "name": "debounce_event_trigger",
      "input": {
        "script": "import { execution } from '@dynatrace-sdk/automation-utils';\nimport { executionsClient } from '@dynatrace-sdk/client-automation';\n\nconst main = async ({ execution_id }) => {\n  const log = new Log('DEBUG')\n  \n  // Get details of current workflow\n  const ex = await execution(execution_id);\n  const workflowId = ex.workflow;\n  const startedAt = ex.startedAt;\n  const event = ex?.params?.event || {};\n  \n  const eventId = event['event.id'];\n  log.debug('eventId', eventId);\n  \n  const eventStatus = event['event.status'];\n  log.debug('eventStatus', eventStatus);\n  \n  const eventStatusTransition = event['event.status_transition'];\n  log.debug('eventStatusTransition', eventStatusTransition);\n\n  // Retrieve all executions within the last 30 mins\n  // (as this is how long a problwm will stay resolved \n  // before it eventually being closed)\n\n  const startedAtLte = new Date(startedAt);\n  const startedAtGte = new Date(startedAt);\n  startedAtGte.setMinutes(startedAtLte.getMinutes() - 30);\n  log.debug('filtering startedAt between', startedAtGte, 'and', startedAtLte);\n  \n  const getExecutionsConfig = {\n    workflow: [workflowId],\n    ordering: ['-startedAt'],\n    startedAtLte: startedAtLte.toISOString(),\n    startedAtGte:  startedAtGte.toISOString()\n  };\n  const { results } = await executionsClient.getExecutions(getExecutionsConfig);\n  \n  // Get last execution that was triggered by \n  // same 'event.id' and parse 'event.status' and\n  // 'event.status_transition'\n\n  for (const previousEx of results) {\n    const previousEvent = previousEx?.params?.event || {};\n    const previousEventId = previousEvent['event.id'];\n    log.debug('previous eventId', previousEventId);\n\n    const isSameEventId = previousEventId === eventId;\n\n    if (isSameEventId) {\n      log.debug('matching eventId detected');\n      \n      const previousEventStatus = previousEvent['event.status'];\n      log.debug('previous eventStatus', previousEventStatus);\n      \n      const previousEventStatusTransition = previousEvent['event.status_transition'];\n      log.debug('previous eventStatusTransition', previousEventStatusTransition);\n\n      const isSameStatus = previousEventStatus === eventStatus;\n      const isSameStatusTransition = previousEventStatusTransition === eventStatusTransition;\n\n      const isUnique = !(isSameStatus && isSameStatusTransition);\n      log.debug('unique event:', isUnique);\n      \n      return { isUnique };\n    }\n  }\n  \n  return { isUnique: true };\n}\n\nclass Log {\n  constructor(logLevel) {\n    this.logLevel = logLevel;\n  }\n\n  ERROR = 'ERROR'\n  INFO = 'INFO'\n  DEBUG = 'DEBUG'\n\n  debug(...msg) {\n    // Only log if level is set to debug\n    if (this.logLevel === this.DEBUG) {\n      console.log(...msg);\n    }\n  }\n\n  info(...msg) {\n    // Log if level is set to info, debug, or unknown value (default)\n    if (this.logLevel == this.INFO || this.logLevel == this.DEBUG) {\n      console.log(...msg);\n    }\n  }\n\n  error(...msg) {\n    // Always log error\n    console.error(...msg);\n  }\n}\n\nexport { main as default };\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 1
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "trigger_remediation": {
      "name": "trigger_remediation",
      "input": {
        "script": "import { execution } from '@dynatrace-sdk/automation-utils';\nimport { workflowsClient } from '@dynatrace-sdk/client-automation';\n\nexport default async function ({ execution_id }) {\n  // Get details of current workflow\n  const ex = await execution(execution_id);\n  const params = ex?.params || {};\n\n  const runWorkflowConfig = {\n    id: '{{ auto_remediation_workflow_id }}',\n    body: {\n      params\n    }\n  };\n  const result = await workflowsClient.runWorkflow(runWorkflowConfig);\n  \n  return result;\n}"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 2
      },
      "conditions": {
        "custom": "{% raw %}{{ result('debounce_event_trigger').isUnique }}{% endraw %}",
        "states": {
          "debounce_event_trigger": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "debounce_event_trigger"
      ]
    },
    "discard": {
      "name": "discard",
      "input": {
        "query": "fetch events\n| limit 1"
      },
      "action": "dynatrace.automations:execute-dql-query",
      "position": {
        "x": 1,
        "y": 2
      },
      "conditions": {
        "custom": "{% raw %}{{ not result('debounce_event_trigger').isUnique }}{% endraw %}",
        "states": {
          "debounce_event_trigger": "OK"
        }
      },
      "description": "Executes DQL query",
      "predecessors": [
        "debounce_event_trigger"
      ]
    }
  }
}